# -*- coding: utf-8 -*-
"""Breast Cancer.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RbeDuTYLGRhOPXI4bGm9v3spmH19QAGE
"""

# Step 1: Upload the ZIP file (you've already uploaded the dataset)
from google.colab import files
uploaded = files.upload()

# Step 2: Extract the ZIP file
import zipfile
import os

# Path to extract the files
extract_path = '/content/dataset'
os.makedirs(extract_path, exist_ok=True)

# Get the uploaded file path automatically
zip_file_path = list(uploaded.keys())[0]  # This will get the name of the uploaded file

# Extract the ZIP file
with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

# List the files to check the extracted contents
extracted_files = os.listdir(extract_path)
print("Extracted files:", extracted_files)

# Step 3: Load and preprocess the dataset
import pandas as pd

# Assuming the extracted dataset is a CSV file (change the filename if needed)
dataset_file = os.path.join(extract_path, 'Breast_GSE45827.csv')  # Replace with actual dataset file name if different

# Load the dataset
data = pd.read_csv(dataset_file)
print("Dataset preview:")
print(data.head())

# Preprocess the dataset: handle missing values (if any)
data_cleaned = data.dropna()  # Example: drop rows with missing values

# Selecting the relevant data (Assuming columns represent genes, and rows represent samples)
X = data_cleaned.iloc[:, 1:].values  # Assuming the first column is sample IDs

# Check the data types and inspect any non-numeric columns
print("Data types of columns:")
print(data_cleaned.dtypes)

# Inspect a few rows of the dataset to identify any non-numeric data
print("Dataset preview with non-numeric columns:")
print(data_cleaned.head())

# Step 4: Apply K-Means Clustering - Handle non-numeric data
from sklearn.cluster import KMeans

# Select only numeric columns for clustering
numerical_data = data_cleaned.select_dtypes(include=['float64', 'int64']).values

# Set the number of clusters (as mentioned, 6 classes in your case)
num_clusters = 6
kmeans = KMeans(n_clusters=num_clusters, random_state=42)
kmeans.fit(numerical_data)

# Add the cluster labels to the data
data_cleaned['Cluster'] = kmeans.labels_

print("Clustering complete. Cluster labels added to the dataset.")
print(data_cleaned.head())

# Step 5: Visualize the clustering result using PCA (for dimensionality reduction)
from sklearn.decomposition import PCA
import matplotlib.pyplot as plt

# Select only numeric columns for PCA
numerical_data = data_cleaned.select_dtypes(include=['float64', 'int64']).values

# Apply PCA to reduce dimensions to 2 for visualization
pca = PCA(n_components=2)
principal_components = pca.fit_transform(numerical_data)

# Create a DataFrame for PCA results
pca_df = pd.DataFrame(data=principal_components, columns=['PC1', 'PC2'])
pca_df['Cluster'] = data_cleaned['Cluster']

# Step 6: Plot the PCA results with clustering information
plt.figure(figsize=(8, 6))
scatter = plt.scatter(pca_df['PC1'], pca_df['PC2'], c=pca_df['Cluster'], cmap='viridis')
plt.title('PCA of Clustering Results')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')

# Add a color bar and legend
plt.colorbar(scatter)
legend1 = plt.legend(*scatter.legend_elements(), title="Clusters")
plt.gca().add_artist(legend1)

# Show the plot
plt.show()

# Step 7: Distribution of Gene Expression for Random Genes (boxplot)
import numpy as np

# Pick a few random genes (columns) from the dataset (excluding the first column)
genes_to_plot = np.random.choice(data_cleaned.columns[1:], 3, replace=False)

# Plot the distribution of the selected genes
plt.figure(figsize=(12, 8))
for i, gene in enumerate(genes_to_plot, 1):
    plt.subplot(1, 3, i)
    data_cleaned.boxplot(column=gene, by="Cluster", patch_artist=True)
    plt.title(f'Gene Expression Distribution: {gene}')
    plt.suptitle('')
plt.tight_layout()
plt.show()

# Step 8: Heatmap of Gene Expression (for first few genes)
import seaborn as sns

# Take the first few genes and select only numeric columns
selected_genes = data_cleaned.select_dtypes(include=['float64', 'int64']).columns[:10]  # Take first 10 numeric genes
gene_expression = data_cleaned[selected_genes]

# Plot heatmap
plt.figure(figsize=(12, 8))
sns.heatmap(gene_expression.corr(), annot=True, cmap='coolwarm', fmt=".2f", linewidths=0.5)
plt.title('Heatmap of Gene Expression Correlations')
plt.show()

# Step 9: Elbow Method to Determine Optimal Number of Clusters
from sklearn.cluster import KMeans
import matplotlib.pyplot as plt

# Ensure only numeric columns are selected for clustering
X = data_cleaned.select_dtypes(include=['float64', 'int64']).values

# Compute the inertia for different numbers of clusters (1 to 10)
inertia = []
for i in range(1, 11):
    kmeans = KMeans(n_clusters=i, random_state=42)
    kmeans.fit(X)
    inertia.append(kmeans.inertia_)

# Plot the elbow curve
plt.figure(figsize=(8, 6))
plt.plot(range(1, 11), inertia, marker='o')
plt.title('Elbow Method for Optimal K')
plt.xlabel('Number of Clusters')
plt.ylabel('Inertia')
plt.show()

# Step 10: t-SNE for further Clustering Visualization
from sklearn.manifold import TSNE

# Apply t-SNE for more detailed 2D visualization
tsne = TSNE(n_components=2, random_state=42)
tsne_components = tsne.fit_transform(X)

# Create a DataFrame for t-SNE results
tsne_df = pd.DataFrame(data=tsne_components, columns=['tSNE1', 'tSNE2'])
tsne_df['Cluster'] = data_cleaned['Cluster']

# Plot the t-SNE results
plt.figure(figsize=(8, 6))
scatter_tsne = plt.scatter(tsne_df['tSNE1'], tsne_df['tSNE2'], c=tsne_df['Cluster'], cmap='viridis')
plt.title('t-SNE of Clustering Results')
plt.xlabel('tSNE Component 1')
plt.ylabel('tSNE Component 2')

# Add a color bar and legend
plt.colorbar(scatter_tsne)
legend2 = plt.legend(*scatter_tsne.legend_elements(), title="Clusters")
plt.gca().add_artist(legend2)

plt.show()

# Manually assigning subtypes based on observed gene expression patterns
# This step assumes that you know which genes are most strongly associated with each subtype

# Example: Subtypes based on known genes for Luminal A, Luminal B, HER2-enriched, and Basal-like
# We will use common marker genes to help assign subtypes

# Add a 'Subtype' column to the dataset based on cluster labels
def assign_subtype(cluster):
    if cluster == 0:
        return 'Luminal A'  # Example: Cluster 0 corresponds to Luminal A
    elif cluster == 1:
        return 'Luminal B'  # Example: Cluster 1 corresponds to Luminal B
    elif cluster == 2:
        return 'HER2-enriched'  # Example: Cluster 2 corresponds to HER2-enriched
    elif cluster == 3:
        return 'Basal-like'  # Example: Cluster 3 corresponds to Basal-like
    else:
        return 'Normal-like'  # Example: Cluster 4 corresponds to Normal-like

# Apply the function to assign subtypes
data_cleaned['Subtype'] = data_cleaned['Cluster'].apply(assign_subtype)

# Display the updated dataset with subtypes
print(data_cleaned[['Cluster', 'Subtype']].head())

# Now, visualize the clusters with subtype names
plt.figure(figsize=(8, 6))
scatter = plt.scatter(pca_df['PC1'], pca_df['PC2'], c=pca_df['Cluster'], cmap='viridis')
plt.title('PCA of Breast Cancer Subtypes (Named Clusters)')
plt.xlabel('Principal Component 1')
plt.ylabel('Principal Component 2')
plt.colorbar(scatter)

# Add a color legend to the PCA plot with the subtype names
legend1 = plt.legend(*scatter.legend_elements(), title="Subtypes")
plt.gca().add_artist(legend1)
plt.show()

